#!/usr/bin/python3

import socket
import tkinter
import os
import types
from tkinter import *
from argparse import ArgumentParser
from tkinter import filedialog
import pickle
import selectors
import threading
import tempfile
import subprocess

HOST = '127.0.0.1'
# which port?
PORT = 65442


def is_url(a_str):
    return a_str.startswith('http')


def get_parser():
    parser = ArgumentParser()
    parser.add_argument("-o", dest="output", help="store clip in output file")
    parser.add_argument("-t", "--time", dest="time", help="supply start or end time")
    parser.add_argument("-i", "--input", dest="input", help="supply an input .mp4 file")
    parser.add_argument("-q", "-e", "-k", "--exit", "--quit", action="store_true", dest="quit",
                        help="close server")
    parser.add_argument("-s", "--status", action="store_true", dest="status",
                        help="show status (running jobs)")
    parser.add_argument("--mpv-working-dir", dest="mpv_working_dir")

    parser.add_argument("--finished", dest="finished")  # used only from child processes
    parser.add_argument("--monitor", action="store_true", dest="monitor")
    return parser


class Cut:

    def get_in_file_path(self):
        if os.path.isabs(self.in_filename):
            return self.in_filename
        else:
            if self.working_dir:
                path = os.path.join(self.working_dir, self.in_filename)
                assert(os.path.exists(path))
                return path
            else:
                raise Exception(f"the file {self.in_filename} does not exist, and there is no working directory specified")

    def get_out_file_path(self):
        if not self.out_file_path:
            self.out_file_path = os.path.join(self.base_folder, self.out_filename)

        if not self.out_file_path.endswith(".mp4"):
            self.out_file_path += ".mp4"
        return self.out_file_path

    def __init__(self, in_filename=None, cut_range=[], out_filename=None, working_dir=None, output_folder=None):
        assert(os.path.exists(working_dir))

        self.in_filename = in_filename
        self.cut_range = cut_range
        self.out_filename = out_filename
        self.working_dir = working_dir
        self.reset_start = False
        self.reset_end = False
        self.output_folder = output_folder
        self.out_file_path = None

        # how to handle base and default folder if we use a new filename
        # and if we change the base folder / default folder with the gui?
        self.base_folder = os.path.dirname(self.in_file)
        self.default_folder = os.path.join(self.base_folder, "clips/")

        if not os.path.exists(self.default_folder):
            os.makedirs(self.default_folder)

    def set_begin(self, begin_time_str):
        if len(self.cut_range) == 0:
            self.cut_range.append(begin_time_str)
        else:
            self.cut_range[0] = begin_time_str

    def set_end(self, end_time_str):
        if len(self.cut_range) < 2:
            self.cut_range.append(end_time_str)
        else:
            self.cut_range[1] = end_time_str

    def add_time(self, time_str):
        self.cut_range.append(time_str)

    def clear_time(self):
        self.cut_range.clear()

    def create_thread(self):
        def ffmpeg_worker(ffmpeg_command):
            os.system("ffmpeg" + ffmpeg_command)

        # file name needs to be in quotes, otherwise a name with spaces is
        # seen as separate commands / filenames
        ffmpeg_command = f" -i '{self.in_filename}' -ss {self.cut_range[0]} -to {self.cut_range[1]} '{self.out_filename}'"
        t = threading.Thread(target=ffmpeg_worker, args=(ffmpeg_command,))
        return t


class VidCutter:

    def __init__(self):
        self.threads = []
        self.running = {}
        self.finished = {}
        self.cuts = []
        self.threads = []

    def dl_from_youtube(self, url, out_name):
        tmp_file = tempfile.NamedTemporaryFile()

        check_download_finished = threading.Condition()

        def download_vid(url, out_name):
            check_download_finished.acquire()
            subprocess.run(['youtube-dl', f"{url} -o {out_name}"])
            check_download_finished.release()

        download_vid_thread = threading.Thread(target=download_vid, args=(url, tmp_file.name))
        download_vid_thread.start()

    def cut_youtubedl(self, in_filename_or_url, out_filename, base_folder, cut_range):
        if is_url(in_filename_or_url):
            # video is already downloaded
            if self.url_to_vid[self.url]:
                in_file = self.url_to_vid[self.url]
            else:
                # download it first
                temp_file = tempfile.NamedTemporaryFile()

                def dl_youtube(url, filename):
                    subprocess.call(["youtube-dl", f"{self.url} -o {temp_file.name}"])

                os.system(f"youtube-dl {self.url} -o {temp_file.name}")
                in_file = temp_file.name
                self.url_to_vid
        else:
            cut = Cut(in_filename_or_url=in_filename_or_url, cut_range=self.cut_range.copy(), out_filename=out_filename)
            t = cut.create_thread()
            self.threads.append(t)
            t.start()
            self.running[t] = out_filename

    def add_cut(self, cut):
        cut = Cut()
        t = cut.create_thread()
        self.threads.append(t)
        # insert some condition inside the thread, so it only can start when the video is finished downloading
        t.start()

    def print_status(self):
        print("VFCUT Status:")
        if not self.running:
            print("No running jobs at the moment!")
        if not self.running:
            print("FINISHED")
        else:
            print("RUNNING JOBS:")
            for t, name in self.running.items():
                print(f"running: [{t}] {name}")
        if self.finished:
            print("FINISHED JOBS:")
            for t, name in self.finished.items():
                print(f"finished: [{t}] {name}")
                self.finished.clear()


class VFCutServer:

    def __init__(self, vfcut_socket, selector, argv):
        self.socket = vfcut_socket
        self.cut_range = []
        self.in_file = None
        self.out_file = None
        self.description = None
        self.parser = get_parser()
        self.vid_cutter = VidCutter()

        self.monitor = []

        self.selector = selector
        self.default_folder = '/clips'

        self.current_cut = Cut()

        self.handle_arguments(argv)

    def print_status(self):
        self.vid_cutter.print_status()

    def log(self, key, value):
        print(f"{key} : {value}")

    def accept_wrapper(self, sock):
        conn, addr = sock.accept()  # Should be ready to read
        print("accepted connection from", addr)
        conn.setblocking(False)
        data = types.SimpleNamespace(addr=addr, inb=b"", outb=b"")
        events = selectors.EVENT_READ | selectors.EVENT_WRITE
        self.selector.register(conn, events, data=data)

    def handle_arguments(self, argv):
        self.log('argv', argv)
        try:
            args = self.parser.parse_args(argv)
        except Exception as ex:
            print(ex)
            return

        self.log('args_parsed', args)

        if all(x is None for x in vars(args).values()):
            print("Vfcut: No option specified.")
            # self.parser.print_help()
            # exit(1)
            # RETURN ERROR MESSAGE OR COMMAND TO PRINT ERROR

        if (args.time and not args.input) or (args.input and not args.time):
            print("VFCut: please supply an input filename and a time where you want to cut")
            # self.parser.print_help()
            # exit(1)
            # RETURN ERROR MESSAGE OR COMMAND TO PRINT ERROR

        # ! the order of the parameter handling matters
        # if a new filename appears and the current cut was set to a different filename
        # we need to replace the current cut
        # this happens if you start mpv and start cutting one video
        # then you open a new video and want to cut again, VFCut will have stored the begin time
        # for the old video, in this case recreate a Cut object and start from the beginning
        if args.input:
            # start a new cut
            if self.current_cut.in_filename and args.input != self.current_cut.in_filename:
                self.current_cut = Cut()
            self.current_cut.in_filename = args.input

        if args.mpv_working_dir:
            self.log('mpv_working_dir', args.mpv_working_dir)
            self.mpv_working_dir = args.mpv_working_dir
            self.current_cut.working_dir = args.mpv_working_dir

        # this option is usually only called if we use VFCut solely from the cli
        # otherwise the out_filename should be set by the GUI
        if args.output:
            self.current_cut.out_filename = args.output

        if args.quit:
            exit(0)

        if args.status:
            for t in self.threads:
                print(t.is_alive())
                if not t.is_alive():
                    self.finished[t] = t
                    t.join()
                    del self.running[t]
            self.print_status()

        if args.time:
            if self.current_cut.reset_start:
                self.current_cut.set_begin(args.time)
                self.current_cut.reset_start = False
            elif self.current_cut.reset_end:
                self.current_cut.set_end(args.time)
                self.current_cut.reset_end = False
            else:
                self.current_cut.add_time(args.time)

        # OPEN GUI IF NECESSARY
        if len(self.cut_range) >= 2:
            self.open_confirm_window(args)

    def service_connection(self, key, mask):
        sock = key.fileobj
        data = key.data
        if mask & selectors.EVENT_READ:
            recv_data = sock.recv(1024)  # Should be ready to read
            if recv_data:
                recv_data = pickle.loads(recv_data)
                self.handle_arguments(recv_data)
                print('receive: ' + repr(recv_data))
                # data.outb += recv_data
            else:
                print("closing connection to", data.addr)
                self.selector.unregister(sock)
                sock.close()
        if mask & selectors.EVENT_WRITE:
            if data.outb:
                print("echoing", repr(data.outb), "to", data.addr)
                sent = sock.send(data.outb)  # Should be ready to write
                data.outb = data.outb[sent:]

    def listen_connections(self):
        while True:
            events = self.selector.select(timeout=None)
            for key, mask in events:
                if key.data is None:  # it is from the listening socket
                    self.accept_wrapper(key.fileobj)
                else:
                    self.service_connection(key, mask)

    def open_confirm_window(self, args):
        root = tkinter.Tk()

        bg_color = '#0074D9'
        button_color = '#078cff'  # bg_color #'#001f3f'
        title_font_color = 'black'
        label_bg_color = bg_color
        entry_bg_color = '#bbe0ff'

        root.configure(bg=bg_color)

        def on_closing():
            self.current_cut.clear_time()
            root.destroy()

        root.protocol("WM_DELETE_WINDOW", on_closing)

        root.title("VFCut")
        row = 0
        title = Label(root,
                      text="VFCut",
                      fg=title_font_color,
                      bg=bg_color,
                      font="Helvetica 22 bold italic", width=8)
        padx = 10
        title.grid(row=row, column=0, pady=20, padx=padx)
        row += 1

        max_label_len = 40
        filename_label_text = self.current_cut.get_in_file_path()
        if len(self.current_cut.in_filename) > max_label_len:
            filename_label_text = "...'" + filename_label_text[len(filename_label_text) - max_label_len:] + "'"
        label_filename = Label(root, text=f"File/Url: {filename_label_text}", bg=label_bg_color)
        label_filename.grid(row=row, column=0, columnspan=5)
        row += 1

        label_start = Label(root, text="Start:", bg=label_bg_color)
        label_start.grid(row=row, column=0)

        entry_start = Entry(root, bg=entry_bg_color)
        entry_start.insert(END, self.cut_range[0])
        entry_start.grid(row=row, column=1)

        def reset_start():
            self.current_cut.reset_start = True
            root.destroy()

        set_start_again = Button(root, text="Reset Start", command=reset_start, width=9, bg=button_color)
        set_start_again.grid(row=row, column=2)

        row += 1
        label_end = Label(root, text="Stop:", bg=label_bg_color)
        label_end.grid(row=row, column=0)
        entry_end = Entry(root, bg=entry_bg_color)
        entry_end.insert(END, self.cut_range[1])
        entry_end.grid(row=row, column=1)

        def reset_stop():
            self.current_cut.reset_end = True
            root.destroy()

        set_stop_again = Button(root, text="Reset Stop", command=reset_stop, width=9, bg=button_color)
        set_stop_again.grid(row=row, column=2)

        row += 1

        def load_file():
            root.filename = filedialog.askopenfilename(initialdir="/", title="Select folder",
                                                       filetypes=(("all files", "*.*")))
            self.log('output_folder', root.filename)



        label_output_folder = Label(root, text="Output Folder:", bg=label_bg_color)
        label_output_folder.grid(row=row, column=0)
        entry_output_folder = Entry(root, bg=entry_bg_color)
        entry_output_folder.insert(END, self.default_folder)
        entry_output_folder.grid(row=row, column=1, padx=10)
        output_button = Button(root, text="Browse", command=load_file, width=9, bg=button_color)
        output_button.grid(row=row, column=2, sticky=W)

        row += 1
        label_filename = Label(root, text="Output Filename: ", bg=label_bg_color)
        label_filename.grid(row=row, column=0)

        entry_name = Entry(root, bg=entry_bg_color)
        entry_name.grid(row=row, column=1)
        entry_name.focus()

        def create_cut(event=None):
            self.current_cut.base_folder = os.path.join(self.current_cut.base_folder, self.default_folder)
            self.vid_cutter.add_cut(self.current_cut)
            self.current_cut = Cut()
            root.destroy()

        row += 2

        create_button = Button(root, text="Create", command=create_cut, width=9, bg=button_color)
        create_button.grid(row=row, column=1, pady=10)

        row += 1

        clear_button = Button(root, text="Cancel", command=on_closing, width=9, height=1, bg=button_color)
        clear_button.grid(row=row, column=0, pady=10)

        row += 2

        label_help = Label(root, text="Insert filename and hit enter or click 'Create' button", bg=label_bg_color)
        label_help.grid(row=row, column=0, columnspan=4, pady=30)

        entry_name.bind('<Return>', create_cut)
        root.geometry('500x450')
        root.mainloop()


class VFCutClient:
    def __init__(self, argv):
        self.selector = selectors.DefaultSelector()
        self.messages = [argv]

    def run_eventloop(self):
        while True:
            events = self.selector.select(timeout=1)
            if events:
                for key, mask in events:
                    self.service_connection(key, mask)
            if not self.selector.get_map():
                break

    # CLIENT
    def service_connection(self, key, mask):
        sock = key.fileobj
        data = key.data
        if mask & selectors.EVENT_READ:
            recv_data = sock.recv(1024)  # Should be ready to read
            if recv_data:
                print("received", repr(recv_data), "from connection", data.connid)
                data.recv_total += len(recv_data)
            if not recv_data or data.recv_total == data.msg_total:
                print("closing connection", data.connid)
                self.selector.unregister(sock)
                sock.close()
        if mask & selectors.EVENT_WRITE:
            if not data.outb and data.messages:
                data.outb = pickle.dumps(data.messages.pop(0))
            if data.outb:
                print("sending", repr(data.outb), "to connection", data.connid)
                sent = sock.send(data.outb)  # Should be ready to write
                data.outb = data.outb[sent:]

    # CLIENT
    def connect_to_server(self, host, port):
        server_addr = (host, port)
        connid = 0  # remove?
        print("starting connection", connid, "to", server_addr)
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setblocking(False)
        sock.connect_ex(server_addr)
        events = selectors.EVENT_READ | selectors.EVENT_WRITE
        data = types.SimpleNamespace(
            connid=connid,
            msg_total=sum(len(m) for m in self.messages),
            recv_total=0,
            messages=list(self.messages),
            outb=b"",
        )
        self.selector.register(sock, events, data=data)
        return sock


# SERVER
def setup_server_socket():
    selector = selectors.DefaultSelector()
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # AF_INET --> internet family ipv4, SOCK_STREAM --> TCP
    sock.bind((HOST, PORT))
    sock.listen()
    print('listening on', (HOST, PORT))
    sock.setblocking(False)
    selector.register(sock, selectors.EVENT_READ, data=None)
    return sock, selector


def main():
    # temporary turn off forking, so we can debug the application better
    # if os.fork():
    #    sys.exit()
    import time
    argv = sys.argv[1:]
    # we are the first process (server
    try:
        vfcut_socket, selector = setup_server_socket()
    except Exception as toplevelex:
        print(toplevelex)
        # there is already a server, so we relay arguments to it
        client = VFCutClient(argv)
        client_sock = client.connect_to_server(HOST, PORT)
        try:
            client.run_eventloop()
        except Exception as ex:
            print(ex)
            client_sock.close()
            exit(1)
        finally:
            exit(0)

    try:
        server = VFCutServer(vfcut_socket, selector, argv)
        server.listen_connections()
    except Exception as ex:
        print(ex)
    finally:
        vfcut_socket.close()


if __name__ == "__main__":
    main()

#!/usr/bin/python3

import socket
import tkinter
import os
from tkinter import *
from optparse import OptionParser
from tkinter import filedialog

HOST = '127.0.0.1'
PORT = 65442


# 1. supply begin time
# vfcut -t 00:00:00 -i somefile.mp4
# 2. supply end time
# vfcut -t 00:01:40 -i somefile.mp4
# 3. open tkinter window
# 4. type in filename
# 5. type in description
# 6. press enter to save or type in metadata
# 7. use ffmpeg to cut video (given by mpv)


class VFCutServer:

    def __init__(self, vfcut_socket, options):
        self.socket = vfcut_socket
        self.options = options
        self.time = []
        self.in_file = None
        self.out_file = None
        self.description = None
        self.running = {}
        self.finished = {}
        if options.time:
            self.time.append(options.time.strip())
        if options.input:
            self.in_file = options.input
        if options.output:
            self.out_file = options.output
        if options.status:
            self.print_status()


    def print_status(self):
        print("VFCUT Status:")
        if not self.running:
            print("No running jobs at the moment!")
        for pid, name in self.running.items():
            print(f"running: [{pid}] {name}")
        for pid, name in self.finished.items():
            print(f"finished: [{pid}] {name}")
            self.finished.clear()

    def listen_connections(self):
        self.socket.listen()
        conn, addr = self.socket.accept()
        with conn:
            while True:
                data = conn.recv(1024)
                if not data:
                    break
                data_str = data.decode('ascii')
                dt = data_str.split()
                if dt[0] == "time":
                    if len(self.time) > 1:
                        self.time[0] = dt[1]
                    else:
                        self.time.append(dt[1])
                    if len(self.time) >= 2:
                        self.open_confirm_window(self.options)
                elif dt[0] == "output":
                    output = dt[1]
                elif dt[0] == "quit":
                    exit(0)
                elif dt[0] == "finished":
                    pid = int(dt[1])
                    print("vfcut: " + self.running[pid] + " finished!")
                    self.finished[pid] = self.running[pid]
                    del self.running[pid]
                    os.waitpid(int(dt[1]))
                elif dt[0] == "status":
                    self.print_status()
                elif dt[0] == "quit":
                    exit(0)
                conn, addr = self.socket.accept()

    def open_confirm_window(self, options):
        root = tkinter.Tk()

        bg_color = '#0074D9'
        button_color = '#078cff' #bg_color #'#001f3f'
        title_font_color='black'
        label_bg_color=bg_color
        entry_bg_color='#bbe0ff'

        root.configure(bg=bg_color)

        def on_closing():
            print('close')
            self.time.clear()
            root.destroy()

        root.protocol("WM_DELETE_WINDOW", on_closing)

        root.title("VFCut")
        row = 0
        title = Label(root,
                      text="VFCut",
                      fg=title_font_color,
                      bg=bg_color,
                      font="Helvetica 22 bold italic", width=8)
        padx = 10
        title.grid(row=row, column=0, pady=20, padx=padx)
        row += 1

        label_start = Label(root, text="Start:", bg=label_bg_color)
        label_start.grid(row=row, column=0)


        entry_start = Entry(root, bg=entry_bg_color)
        entry_start.insert(END, self.time[0])
        entry_start.grid(row=row, column=1)

        def reset_start():
            root.destroy()

        set_start_again = Button(root, text="Reset Start", command=reset_start, width=9, bg=button_color)
        set_start_again.grid(row=row, column=2)


        row += 1
        label_end = Label(root, text="Stop:", bg=label_bg_color)
        label_end.grid(row=row, column=0)
        entry_end = Entry(root, bg=entry_bg_color)
        entry_end.insert(END, self.time[1])
        entry_end.grid(row=row, column=1)

        def reset_stop():
            del self.time[1]
            root.destroy()

        set_stop_again = Button(root, text="Reset Stop", command=reset_stop, width=9, bg=button_color)
        set_stop_again.grid(row=row, column=2)

        row += 1
        def load_file():
            print("load")
            root.filename = filedialog.askopenfilename(initialdir="/", title="Select file",
                                                       filetypes=(("jpeg files", "*.jpg"), ("all files", "*.*")))
            print(root.filename)

        in_file = options.input.strip().replace(' ', '\ ')

        base_folder = os.path.dirname(options.input.strip())
        default_folder = os.path.join(base_folder, "clips/")


        if not os.path.exists(default_folder):
            os.makedirs(default_folder)
            print('create new folder: ' + default_folder)
        label_output_folder = Label(root, text="Output Folder:", bg=label_bg_color)
        label_output_folder.grid(row=row, column=0)
        entry_output_folder = Entry(root, bg=entry_bg_color)
        entry_output_folder.insert(END, default_folder)
        entry_output_folder.grid(row=row, column=1,padx=10)
        output_button = Button(root, text="Browse", command=load_file, width=9, bg=button_color)
        output_button.grid(row=row, column=2, sticky=W)

        row += 1
        label_filename = Label(root, text="Output Filename: ", bg=label_bg_color)
        label_filename.grid(row=row, column=0)

        entry_name = Entry(root, bg=entry_bg_color)
        entry_name.grid(row=row, column=1)
        entry_name.focus()

        def create_cut(event=None):
            out_file = os.path.join(default_folder, entry_name.get())
            if not out_file.endswith(".mp4"):
                out_file += ".mp4"
            print('Create file: ' + out_file)
            child = os.fork()
            if child == 0:
                ffmpeg_command = f" -i {in_file} -ss {self.time[0]} -to {self.time[1]} {out_file}"
                print('run: ffmpeg' + "".join(ffmpeg_command))
                os.system("ffmpeg " + ffmpeg_command)
                send_to_server(to_bin("finished " + str(os.getpid())))
                exit(0)
            else:
                self.running[child] = out_file
            self.time.clear()
            root.destroy()

        row += 2

        create_button = Button(root, text="Create", command=create_cut, width=9, bg=button_color)
        create_button.grid(row=row, column=1, pady=10)


        row += 1

        clear_button = Button(root, text="Cancel", command=on_closing, width=9, height=1, bg=button_color)
        clear_button.grid(row=row, column=0, pady=10)



        row += 2

        label_help = Label(root, text="Insert filename and hit enter or click 'Create' button", bg=label_bg_color)
        label_help.grid(row=row, column=0, columnspan=4, pady=30)



        entry_name.bind('<Return>', create_cut)
        root.geometry('500x450')
        root.mainloop()


def send_to_server(message):
    print('send to server ' + str(message))
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((HOST, PORT))
        s.sendall(message)


def to_bin(a_str):
    return a_str.encode('ascii')


def connect_server(options):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((HOST, PORT))
    return s


def main():
    if os.fork():
        sys.exit()
    parser = OptionParser()
    parser.add_option("-o", dest="output", help="store clip in output file", metavar="FILE")
    parser.add_option("-t", "--time", dest="time", help="supply start or end time", metavar="TIME")
    parser.add_option("-i", "--input", dest="input", help="supply an input .mp4 file", metavar="INPUT")
    parser.add_option("-q", "-e", "-k", "--exit", "--quit", action="store_true", dest="quit", help="close server", metavar="QUIT")
    parser.add_option("-s", "--status", action="store_true", dest="status", help="show status (running jobs)", metavar="STATUS")
    (options, args) = parser.parse_args()

    if all(x is None for x in vars(options).values()):
        print("Vfcut: No option specified.")
        parser.print_help()
        exit(1)

    if (options.time and not options.input) or (options.input and not options.time):
        print("VFCut: please supply an input filename and a time where you want to cut")
        parser.print_help()
        exit(1)

    try:
        vfcut_socket = connect_server(options)
        server = VFCutServer(vfcut_socket, options)
        server.listen_connections()
    except:
        if options.time:
            send_to_server(to_bin("time " + options.time))
        if options.input:
            send_to_server(to_bin("input " + options.input))
        if options.output:
            send_to_server(to_bin("output " + options.output))
        if options.quit:
            send_to_server(to_bin("quit " + options.quit))
        if options.status:
            send_to_server(to_bin("status"))
        if options.quit:
            send_to_server(to_bin("quit"))


if __name__ == "__main__":
    main()

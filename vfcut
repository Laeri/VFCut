#!/usr/bin/python3

import socket
import tkinter
import os
import types
from tkinter import *
from argparse import ArgumentParser
from tkinter import filedialog
import pickle
import selectors

HOST = '127.0.0.1'
# which port do we choose?
PORT = 65442


# 1. supply begin time
# vfcut -t 00:00:00 -i somefile.mp4
# 2. supply end time
# vfcut -t 00:01:40 -i somefile.mp4
# 3. open tkinter window
# 4. type in filename
# 5. type in description
# 6. press enter to save or type in metadata
# 7. use ffmpeg to cut video (given by mpv)


class VFCutServer:

    def __init__(self, vfcut_socket, selector, argv):
        self.socket = vfcut_socket
        self.time = []
        self.in_file = None
        self.out_file = None
        self.description = None
        self.running = {}
        self.finished = {}
        self.parser = ArgumentParser()
        self.parser.add_argument("-o", dest="output", help="store clip in output file")
        self.parser.add_argument("-t", "--time", dest="time", help="supply start or end time")
        self.parser.add_argument("-i", "--input", dest="input", help="supply an input .mp4 file")
        self.parser.add_argument("-q", "-e", "-k", "--exit", "--quit", action="store_true", dest="quit",
                                 help="close server")
        self.parser.add_argument("-s", "--status", action="store_true", dest="status",
                                 help="show status (running jobs)")

        self.parser.add_argument("--finished", dest="finished")  # used only from child processes
        self.parser.add_argument("--monitor", dest="monitor")

        args = self.parser.parse_args(argv)
        self.args = args
        if args.time:
            self.time.append(args.time.strip())
        if args.input:
            self.in_file = args.input
        if args.output:
            self.out_file = args.output
        if args.status:
            self.print_status()

        self.selector = selector

    def print_status(self):
        print("VFCUT Status:")
        if not self.running:
            print("No running jobs at the moment!")
        for pid, name in self.running.items():
            print(f"running: [{pid}] {name}")
        for pid, name in self.finished.items():
            print(f"finished: [{pid}] {name}")
            self.finished.clear()

    def accept_wrapper(self,sock):
        conn, addr = sock.accept()  # Should be ready to read
        print("accepted connection from", addr)
        conn.setblocking(False)
        data = types.SimpleNamespace(addr=addr, inb=b"", outb=b"")
        events = selectors.EVENT_READ | selectors.EVENT_WRITE
        self.selector.register(conn, events, data=data)

    def service_connection(self, key, mask):
        sock = key.fileobj
        data = key.data
        if mask & selectors.EVENT_READ:
            recv_data = sock.recv(1024)  # Should be ready to read
            if recv_data:
                print('receive: ' + repr(recv_data))
                #data.outb += recv_data
            else:
                print("closing connection to", data.addr)
                self.selector.unregister(sock)
                sock.close()
        if mask & selectors.EVENT_WRITE:
            if data.outb:
                print("echoing", repr(data.outb), "to", data.addr)
                sent = sock.send(data.outb)  # Should be ready to write
                data.outb = data.outb[sent:]

    def listen_connections(self):
        while True:
            events = self.selector.select(timeout=None)
            for key, mask in events:
                if key.data is None:  # it is from the listening socket
                    self.accept_wrapper(key.fileobj)
                else:
                    self.service_connection(key, mask)

            tmp = """self.print_status()
            data = conn.recv(1024)
            if not data:
                break
            argv = pickle.loads(data)
            args = self.parser.parse_args(argv)

            if all(x is None for x in vars(args).values()):
                print("Vfcut: No option specified.")
                self.parser.print_help()
                exit(1)

            if (args.time and not args.input) or (args.input and not args.time):
                print("VFCut: please supply an input filename and a time where you want to cut")
                self.parser.print_help()
                exit(1)

            print(f"RECEIVED: {argv}")
            if args.time:
                if len(self.time) > 1:
                    self.time[0] = args.time
                else:
                    # only append when the stop time of the clip
                    # differs from the start time
                    # you can use the same shortcut to continue the clip after starting the cut
                    if not self.time or (args.time != self.time[0]):
                        self.time.append(args.time)
                if len(self.time) >= 2:
                    self.open_confirm_window(self.options)
            if args.output:
                output = args.output
            if args.quit:
                print('server quit')
                exit(0)
            if args.finished:
                pid = int(args.finished)
                print("vfcut: " + self.running[pid] + " finished!")
                self.finished[pid] = self.running[pid]
                del self.running[pid]
                os.waitpid(pid)
            if args.status:
                self.print_status()"""

    def open_confirm_window(self, options):
        root = tkinter.Tk()

        bg_color = '#0074D9'
        button_color = '#078cff'  # bg_color #'#001f3f'
        title_font_color = 'black'
        label_bg_color = bg_color
        entry_bg_color = '#bbe0ff'

        root.configure(bg=bg_color)

        def on_closing():
            self.time.clear()
            root.destroy()

        root.protocol("WM_DELETE_WINDOW", on_closing)

        root.title("VFCut")
        row = 0
        title = Label(root,
                      text="VFCut",
                      fg=title_font_color,
                      bg=bg_color,
                      font="Helvetica 22 bold italic", width=8)
        padx = 10
        title.grid(row=row, column=0, pady=20, padx=padx)
        row += 1

        label_start = Label(root, text="Start:", bg=label_bg_color)
        label_start.grid(row=row, column=0)

        entry_start = Entry(root, bg=entry_bg_color)
        entry_start.insert(END, self.time[0])
        entry_start.grid(row=row, column=1)

        def reset_start():
            root.destroy()

        set_start_again = Button(root, text="Reset Start", command=reset_start, width=9, bg=button_color)
        set_start_again.grid(row=row, column=2)

        row += 1
        label_end = Label(root, text="Stop:", bg=label_bg_color)
        label_end.grid(row=row, column=0)
        entry_end = Entry(root, bg=entry_bg_color)
        entry_end.insert(END, self.time[1])
        entry_end.grid(row=row, column=1)

        def reset_stop():
            del self.time[1]
            root.destroy()

        set_stop_again = Button(root, text="Reset Stop", command=reset_stop, width=9, bg=button_color)
        set_stop_again.grid(row=row, column=2)

        row += 1

        def load_file():
            root.filename = filedialog.askopenfilename(initialdir="/", title="Select file",
                                                       filetypes=(("jpeg files", "*.jpg"), ("all files", "*.*")))
            print(root.filename)

        in_file = options.input.strip().replace(' ', '\ ')

        base_folder = os.path.dirname(options.input.strip())
        default_folder = os.path.join(base_folder, "clips/")

        if not os.path.exists(default_folder):
            os.makedirs(default_folder)

        label_output_folder = Label(root, text="Output Folder:", bg=label_bg_color)
        label_output_folder.grid(row=row, column=0)
        entry_output_folder = Entry(root, bg=entry_bg_color)
        entry_output_folder.insert(END, default_folder)
        entry_output_folder.grid(row=row, column=1, padx=10)
        output_button = Button(root, text="Browse", command=load_file, width=9, bg=button_color)
        output_button.grid(row=row, column=2, sticky=W)

        row += 1
        label_filename = Label(root, text="Output Filename: ", bg=label_bg_color)
        label_filename.grid(row=row, column=0)

        entry_name = Entry(root, bg=entry_bg_color)
        entry_name.grid(row=row, column=1)
        entry_name.focus()

        def create_cut(event=None):
            out_file = os.path.join(default_folder, entry_name.get())
            if not out_file.endswith(".mp4"):
                out_file += ".mp4"

            child = os.fork()
            if child == 0:
                ffmpeg_command = f" -i {in_file} -ss {self.time[0]} -to {self.time[1]} {out_file}"
                # print('run: ffmpeg' + "".join(ffmpeg_command))
                os.system("ffmpeg " + ffmpeg_command)
                argv = ['--finished', str(os.getpid())]
                #send_to_server(argv)
                exit(0)
            else:
                self.running[child] = out_file
            self.time.clear()
            root.destroy()

        row += 2

        create_button = Button(root, text="Create", command=create_cut, width=9, bg=button_color)
        create_button.grid(row=row, column=1, pady=10)

        row += 1

        clear_button = Button(root, text="Cancel", command=on_closing, width=9, height=1, bg=button_color)
        clear_button.grid(row=row, column=0, pady=10)

        row += 2

        label_help = Label(root, text="Insert filename and hit enter or click 'Create' button", bg=label_bg_color)
        label_help.grid(row=row, column=0, columnspan=4, pady=30)

        entry_name.bind('<Return>', create_cut)
        root.geometry('500x450')
        root.mainloop()


class VFCutClient:
    def __init__(self):
        self.selector = selectors.DefaultSelector()
        self.messages = [b'MESSage1', b'message 2', b'message3']

    def run_eventloop(self):
        while True:
            events = self.selector.select(timeout=1)
            if events:
                for key, mask in events:
                    self.service_connection(key, mask)
            if not self.selector.get_map():
                break
    # CLIENT
    def service_connection(self, key, mask):
        sock = key.fileobj
        data = key.data
        if mask & selectors.EVENT_READ:
            recv_data = sock.recv(1024)  # Should be ready to read
            if recv_data:
                print("received", repr(recv_data), "from connection", data.connid)
                data.recv_total += len(recv_data)
            if not recv_data or data.recv_total == data.msg_total:
                print("closing connection", data.connid)
                self.selector.unregister(sock)
                sock.close()
        if mask & selectors.EVENT_WRITE:
            if not data.outb and data.messages:
                data.outb = data.messages.pop(0)
            if data.outb:
                print("sending", repr(data.outb), "to connection", data.connid)
                sent = sock.send(data.outb)  # Should be ready to write
                data.outb = data.outb[sent:]

    # CLIENT
    def start_connections(self, host, port, num_conns):
        server_addr = (host, port)
        for i in range(0, num_conns):
            connid = i + 1
            print("starting connection", connid, "to", server_addr)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.setblocking(False)
            sock.connect_ex(server_addr)
            events = selectors.EVENT_READ | selectors.EVENT_WRITE
            data = types.SimpleNamespace(
                connid=connid,
                msg_total=sum(len(m) for m in self.messages),
                recv_total=0,
                messages=list(self.messages),
                outb=b"",
            )
            self.selector.register(sock, events, data=data)
# SERVER
def setup_server_socket():
    selector = selectors.DefaultSelector()
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # AF_INET --> internet family ipv4, SOCK_STREAM --> TCP
    sock.bind((HOST, PORT))
    sock.listen()
    print('listening on', (HOST, PORT))
    sock.setblocking(False)
    selector.register(sock, selectors.EVENT_READ, data=None)
    return sock, selector

def main():
    # temporary turn off forking, so we can debug the application better
    # if os.fork():
    #    sys.exit()
    import time
    args = sys.argv[1:]

    # we are the first process (server
    try:
        vfcut_socket, selector = setup_server_socket()
        print('SERV')
    except:
        # there is already a server, so we relay arguments to it
        print("CLIENT")
        client = VFCutClient()
        client.start_connections(HOST, PORT, 1)
        client.run_eventloop()

        # send_to_server(args)
        print('send to server finished, exiting!')
        exit(0)

    server = VFCutServer(vfcut_socket, selector, args)
    server.listen_connections()


if __name__ == "__main__":
    main()
